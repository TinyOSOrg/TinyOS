# 系统概述

<!-- TOC -->

- [系统概述](#%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0)
    - [启动](#%E5%90%AF%E5%8A%A8)
        - [MBR](#mbr)
        - [bootloader](#bootloader)
    - [内核初始化](#%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96)
        - [中断](#%E4%B8%AD%E6%96%AD)

<!-- /TOC -->

## 启动

### MBR

按照启动约定，x86计算机的BIOS会在启动后将满足要求的硬盘的0号扇区加载到物理地址`0x7c00`处，并跳转过去执行。在TinyOS中，`src/boot/mbr.s`中的代码就是该跳转的目标。0号扇区可用空间仅有510字节，不足以加载并初始化内核，故`mbr.s`从磁盘的1号扇区开始，连续读取了4个扇区的内容，放置在物理内存的`0x900`处，并跳转到该地址继续执行。

### bootloader

`mbr.s`中的代码跳转的目标是所谓的`bootloader`，它依次完成以下几项任务：

1. 探测内存容量，存放在物理地址为`TOTAL_MEMORY_SIZE_ADDR`（在`src/boot/boot.s`中定义）的双字中。
2. 打开A20地址线，设置GDT（全局段描述符），进入保护模式。
3. 从磁盘中加载elf格式的内核文件。
4. 启用分页机制。
5. 进入内核代码。

`bootloader`一开始准备的全局段描述符有以下三个：

1. 内核代码段，覆盖0~4GB的地址空间，特权级为0，为非一致性可执行段。
2. 内核数据段，覆盖0~4GB的地址空间，特权级为0，为可读写数据段。
3. 显存段，覆盖从`0xb8000`开始的4000字节，专门用于字符显示模式下屏幕上的输出控制。

初始物理内存分配如下：
1. 0~1MB为内核代码和显存。
2. 1~2MB为一开始的内核栈。
3. 2~3MB为初始时的页目录、页表。
4. 3~4MB保留为内核以后使用。

初始虚拟地址空间分配如下：
1. 0~4MB虚拟地址直接映射到0~4MB物理地址。
2. 3GB~(3GB + 4MB)虚拟地址映射到0~4MB物理地址。自此以后，任何虚拟地址空间的3GB以上位置均为内核使用。

初始页目录和页表分配如下：
1. 物理地址2MB处的4KB为页目录，之后的255 * 4KB为255个页表。
2. 页目录第0项指向第0个页表，而第0个页表覆盖了物理地址的0~4MB。
3. 页目录第768项指向第0个页表，第769项指向第1个页表，以此类推直到第1022项。
4. 页目录最后一项指向页目录本身所在的物理页，这是一个trick，基于此项，以后可使用精心构造的虚拟地址来访问页目录、页表。

在这里，页目录中与3GB~(4GB - 4KB)对应的页表项都被设置完毕，以后任何其他的虚拟地址空间的高1GB也使用这些页表，这样就实现了所有虚拟地址空间都共享这部分内核空间。

## 内核初始化

`bootloader`最终进入内核代码时，跳转的目标实现于`src/kernel/main.c`中。

### 中断

内核初始化的第一步是实现对中断的支持，相关代码位于

> src/include/kernel/intr_entry.h
> src/kernel/intr/intr_entry.c
> src/kernel/intr/intr_entry.s

中断初始化由两部分构成，一是设置中断控制器8259A的参数，二是使用`lidt`指令设置中断描述符表。TinyOS的中断入口是`intr_entry.s`中定义的一系列`INTR_VECTOR`，该入口负责寄存器现场的保存与恢复等工作。进入中断入口并保存好现场后，`intr_entry.c`中定义的`intr_function`会被调用，后者才是真正意义上的中断处理函数。

（施工中……）
